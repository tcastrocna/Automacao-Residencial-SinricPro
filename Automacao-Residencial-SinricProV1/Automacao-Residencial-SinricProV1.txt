#ifdef ENABLE_DEBUG
       #define DEBUG_ESP_PORT Serial
       #define NODEBUG_WEBSOCKETS
       #define NDEBUG
#endif 

//Incluir bibliotecas necessárias.
#ifdef ESP8266 
       #include <ESP8266WiFi.h>
#endif 
#ifdef ESP32   
       #include <WiFi.h>
#endif

#include <Arduino.h>
#include "SinricPro.h"
#include "SinricProSwitch.h"

//Definir nome e senha da rede WiFi e chaves de autenticação da platadorma Sinric Pro.
#define NOME_WIFI           "xxxxxxx"    
#define SENHA_WIFI          "xxxxxxx"
#define CHAVE_APP           "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"      
#define SENHA_APP           "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"   

//Definir os IDs dos dispositovos criados na plataforma Sinric Pro.
#define ID_DISPOSITIVO_1    "xxxxxxxxxxxxxxxxxxxxxxxx"
#define ID_DISPOSITIVO_2    "xxxxxxxxxxxxxxxxxxxxxxxx"
#define ID_DISPOSITIVO_3    "xxxxxxxxxxxxxxxxxxxxxxxx"

//Definir os pinos dos botões físicos .
#define PINO_BOTAO_1 13   //Botão da Iluminação 1
#define PINO_BOTAO_2 12   //Botão da Iluminação 2
#define PINO_BOTAO_3 14   //Botão do Ventilador

//Define os pinos dos relés.
#define PINO_RELE_1 18    //Relé da Iluminação 1
#define PINO_RELE_2 19    //Relé da Iluminação 2
#define PINO_RELE_3 23    //Relé do Ventilador

#define LED_WIFI    16

#define TAXA_DE_TRANSMISSAO  9600          

bool myPowerState1 = false;
bool myPowerState2 = false;
bool myPowerState3  = false;

unsigned long lastBtnPress1 = 0;
unsigned long lastBtnPress2 = 0;
unsigned long lastBtnPress3 = 0;


//Controle através do aplicativo.
bool onPowerState1(const String &deviceId, bool &state) {
  Serial.printf("Device %s turned %s (via SinricPro) \r\n", deviceId.c_str(), state?"on":"off");
  myPowerState1 = state;
  digitalWrite(PINO_RELE_1, myPowerState1?LOW:HIGH);
  return true;      //Pedido tratado corretamente
}
bool onPowerState2(const String &deviceId, bool &state) {
  Serial.printf("Device %s turned %s (via SinricPro) \r\n", deviceId.c_str(), state?"on":"off");
  myPowerState2 = state;
  digitalWrite(PINO_RELE_2, myPowerState2?LOW:HIGH);
  return true;      //Pedido tratado corretamente
}
bool onPowerState3(const String &deviceId, bool &state) {
  Serial.printf("Device %s turned %s (via SinricPro) \r\n", deviceId.c_str(), state?"on":"off");
  myPowerState3 = state;
  digitalWrite(PINO_RELE_3, myPowerState3?LOW:HIGH);
  return true;      //Pedido tratado corretamente
}

//Controle através dos botões físicos
void handleButtonPress() {
  unsigned long actualMillis = millis(); //Obtém o real millis() e o mantém na variável atualMillis
  if (digitalRead(PINO_BOTAO_1) == LOW && actualMillis - lastBtnPress1 > 1000)  { // is button pressed (inverted logic! button pressed = LOW) and debounced?
    if (myPowerState1) {     // flip myPowerState: if it was true, set it to false, vice versa
      myPowerState1 = false;
    } else {
      myPowerState1 = true;
    }
    //Se myPowerState indica que o dispositivo está ligado: liga o relé (o relé usa lógica invertida: LOW = rele ON / HIGH = rele OFF)
    digitalWrite(PINO_RELE_1, myPowerState1?LOW:HIGH); 

    //Recupera o dispositivo Switch
    SinricProSwitch& mySwitch1 = SinricPro[ID_DISPOSITIVO_1];
    //Envia evento powerstate
    mySwitch1.sendPowerStateEvent(myPowerState1);
    Serial.printf("Device %s turned %s (manually via flashbutton)\r\n", mySwitch1.getDeviceId().c_str(), myPowerState1?"on":"off");

    //Atualiza a variável do último botão pressionado
    lastBtnPress1 = actualMillis; 
  } 

if (digitalRead(PINO_BOTAO_2) == LOW && actualMillis - lastBtnPress2 > 1000)  { // is button pressed (inverted logic! button pressed = LOW) and debounced?
    if (myPowerState2) {     // flip myPowerState: if it was true, set it to false, vice versa
      myPowerState2 = false;
    } else {
      myPowerState2 = true;
    }
    //Se myPowerState indica que o dispositivo está ligado: liga o relé (o relé usa lógica invertida: LOW = rele ON / HIGH = rele OFF)
    digitalWrite(PINO_RELE_2, myPowerState2?LOW:HIGH); 

    //Recupera o dispositivo Switch
    SinricProSwitch& mySwitch2 = SinricPro[ID_DISPOSITIVO_2];
    //Envia evento powerstate
    mySwitch2.sendPowerStateEvent(myPowerState2);
    Serial.printf("Device %s turned %s (manually via flashbutton)\r\n", mySwitch2.getDeviceId().c_str(), myPowerState2?"on":"off");

    //Atualiza a variável do último botão pressionado
    lastBtnPress2 = actualMillis; 
  } 

if (digitalRead(PINO_BOTAO_3) == LOW && actualMillis - lastBtnPress3 > 1000)  { // is button pressed (inverted logic! button pressed = LOW) and debounced?
    if (myPowerState3) {     // flip myPowerState: if it was true, set it to false, vice versa
      myPowerState3 = false;
    } else {
      myPowerState3 = true;
    }
    //Se myPowerState indica que o dispositivo está ligado: liga o relé (o relé usa lógica invertida: LOW = rele ON / HIGH = rele OFF)
    digitalWrite(PINO_RELE_3, myPowerState3?LOW:HIGH); 

    //Recupera o dispositivo Switch
    SinricProSwitch& mySwitch3 = SinricPro[ID_DISPOSITIVO_3];
    //Envia evento powerstate
    mySwitch3.sendPowerStateEvent(myPowerState3);
    Serial.printf("Device %s turned %s (manually via flashbutton)\r\n", mySwitch3.getDeviceId().c_str(), myPowerState3?"on":"off");

    //Atualiza a variável do último botão pressionado
    lastBtnPress3 = actualMillis; 
  } 


}

//Função de configuração para conexão WiFi
void setupWiFi() {
  Serial.printf("\r\n[Wifi]: Conectando ");
  WiFi.begin(NOME_WIFI, SENHA_WIFI);

  while (WiFi.status() != WL_CONNECTED) {
    Serial.printf(".");
    digitalWrite(LED_WIFI, HIGH);
    delay(250);
  }
  Serial.printf("Conectado!\r\n[WiFi]: Endereço IP é  %s\r\n", WiFi.localIP().toString().c_str());
}

// setup function for SinricPro
void setupSinricPro() {
  //Adiciona o dispositivo ao SinricPro
  SinricProSwitch& mySwitch1 = SinricPro[ID_DISPOSITIVO_1];
  SinricProSwitch& mySwitch2 = SinricPro[ID_DISPOSITIVO_2];
  SinricProSwitch& mySwitch3 = SinricPro[ID_DISPOSITIVO_3];

  //Define a função de retorno de chamada para o dispositivo.
  mySwitch1.onPowerState(onPowerState1);
  mySwitch2.onPowerState(onPowerState2);
  mySwitch3.onPowerState(onPowerState3);


  //Configurar SinricPro
  SinricPro.onConnected([](){ Serial.printf("Conectada a plataforma SinricPro.\r\n"); }); 
  SinricPro.onDisconnected([](){ Serial.printf("Plataforma SinricPro desconectada.\r\n"); });
  SinricPro.begin(CHAVE_APP, SENHA_APP);
}

//Função de configurações.
void setup() {
  pinMode(PINO_BOTAO_1, INPUT_PULLUP);
  pinMode(PINO_BOTAO_2, INPUT_PULLUP);
  pinMode(PINO_BOTAO_3, INPUT_PULLUP);

  pinMode(PINO_RELE_1, OUTPUT); 
  pinMode(PINO_RELE_2, OUTPUT); 
  pinMode(PINO_RELE_3, OUTPUT); 

  digitalWrite(PINO_RELE_1, !myPowerState1);
  digitalWrite(PINO_RELE_2, !myPowerState1);
  digitalWrite(PINO_RELE_3, !myPowerState1);
  
  digitalWrite(LED_WIFI, LOW);


  Serial.begin(TAXA_DE_TRANSMISSAO); Serial.printf("\r\n\r\n");
  setupWiFi();
  setupSinricPro();
}

void loop() {
  handleButtonPress();
  SinricPro.handle();
}
